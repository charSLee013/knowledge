# 单选题

- [单选题](#单选题)
  - [给定一个有向图 $G = (V,E)$ ，顶点集 $ V = {A,B,C,D,E,F,G,H}$ ，边集 $ E = {(A,B),(A,C),(B,D),(C,D),(C,E),(D,F),(E,G),(F,G),(G,H)}$ ，则下列选项中，属于广度优先搜索(BFS)序列的是:](#给定一个有向图-g--ve-顶点集--v--abcdefgh-边集--e--abacbdcdcedfegfggh-则下列选项中属于广度优先搜索bfs序列的是)
  - [假设有5个进程，它们的到达时间和服务时间如下，单位为ms:](#假设有5个进程它们的到达时间和服务时间如下单位为ms)
  - [已知二叉树有a，b，c，d，e，f，g 这7个节点，二叉树的先序遍历序列的前五个序列是cdfba,二叉树去掉叶子节点的中序遍历序列是 cfdba,则它的后序遍历中第二个度为一的节点是()](#已知二叉树有abcdefg-这7个节点二叉树的先序遍历序列的前五个序列是cdfba二叉树去掉叶子节点的中序遍历序列是-cfdba则它的后序遍历中第二个度为一的节点是)
  - [求关键字13,19,11,9,8,7,21,10 依次插入到初始为空的小根堆H中，得到的H中根节点的值是()](#求关键字1319119872110-依次插入到初始为空的小根堆h中得到的h中根节点的值是)
  - [已知一组关键字为{13,26,47,52,65,78,91,101,117,130}，采用线性探测法处理冲突，散列表是一个下标从0开始的长度为18的一维数组，散列函数为H(Key) = key MOD 18,则关键字65的结点地址是()](#已知一组关键字为13264752657891101117130采用线性探测法处理冲突散列表是一个下标从0开始的长度为18的一维数组散列函数为hkey--key-mod-18则关键字65的结点地址是)
  - [在平面直角坐标系中，起点为(1,1),每一步只能沿着网格线向x轴或者y轴正方向移动1个单位长度。例如，(1,2)走一步只能沿着x轴正方向走到(2,3)或者沿着y轴正方向走到(1,3)。若重点为(5,6)且中途不经过(2,4)的路径有()条？](#在平面直角坐标系中起点为11每一步只能沿着网格线向x轴或者y轴正方向移动1个单位长度例如12走一步只能沿着x轴正方向走到23或者沿着y轴正方向走到13若重点为56且中途不经过24的路径有条)
  - [A和B建立了TCP连接，A端向B端发送数据，MSS=1KB，RTT=15ms。如果线路采用慢开始控制策略，接收窗口为20KB，则A端向B端发送出第一个完全窗口需要多少时间?](#a和b建立了tcp连接a端向b端发送数据mss1kbrtt15ms如果线路采用慢开始控制策略接收窗口为20kb则a端向b端发送出第一个完全窗口需要多少时间)
  - [已知一个有序表(10,16,21,27,36,45,51,62,73,87,96),当二分查找值为51的元素时，查找成功的比较次数为()](#已知一个有序表1016212736455162738796当二分查找值为51的元素时查找成功的比较次数为)
  - [考虑对数方程 $3\\log{k}{\\sqrt{x}\\log{k}{}x};=;56$ 且 $\\log{\\log{k}{x}}{x} ;=; 54$ 。如果这组方程有且仅有一个大于1的实根，那么k的值和唯一的实根为()](#考虑对数方程-3logksqrtxlogkx56-且-loglogkxx--54-如果这组方程有且仅有一个大于1的实根那么k的值和唯一的实根为)
  - [若以{4,6,8,10,12,14}作为叶子结点的权值构造一颗哈夫曼树，则其带权路径长度是()](#若以468101214作为叶子结点的权值构造一颗哈夫曼树则其带权路径长度是)
  - [对数组a=\[3,6,2,9,4,7\]采用快速排序的方法，以第一个元素为基准，从小到大排序，则第一次得到的划分结果是()](#对数组a362947采用快速排序的方法以第一个元素为基准从小到大排序则第一次得到的划分结果是)
  - [串S="backslide"的子串个数为()](#串sbackslide的子串个数为)
  - [考虑函数 $f(x) = ax^{2} - 2021x + 2022$且 $a \> 0 $,如果 $f(x)$在区间 $\[t-1,t+1\]$ 上的最大值为 $Q(t)$,且最小值为 $q(t)$.定义函数 $h(t) = Q(t) - q(t)$， $h(t)$的最小值为1，那么a的可能的值为 ()](#考虑函数-fx--ax2---2021x--2022且-a--0-如果-fx在区间-t-1t1-上的最大值为-qt且最小值为-qt定义函数-ht--qt---qt-ht的最小值为1那么a的可能的值为-)
  - [下列关于MySQL内建的存储引擎Mmeory引擎说法错误是()](#下列关于mysql内建的存储引擎mmeory引擎说法错误是)


## 给定一个有向图 $G = (V,E)$ ，顶点集 $ V = {A,B,C,D,E,F,G,H}$ ，边集 $ E = {(A,B),(A,C),(B,D),(C,D),(C,E),(D,F),(E,G),(F,G),(G,H)}$ ，则下列选项中，属于广度优先搜索(BFS)序列的是:

A. A,B,D,F,G,H,C,E

B. A,B,C,D,E,F,G,H

C. A,C,B,D,F,G,H,E

D. A,C,E,G,H,B,D,F


<details close>
<summary>答案解析</summary>

广度优先搜索是一种图形搜索算法，它从图中的某个顶点出发，按照与源顶点的距离顺序探索顶点，即先访问最近的邻居节点，然后再移动到下一级邻居12。广度优先搜索的实现一般采用队列来存储待访问的节点3。

根据广度优先搜索的定义，我们可以判断题目中的选项是否符合要求。首先，我们可以画出题目给定的有向图，如下：
```
# 用 ASCII 字符画出有向图
# A -> B -> D -> F
# |    ^    ^    |
# v   /     |    v
# C -/      |-> G -> H
# |         |
# v         v
# E --------/
```

然后，我们可以按照广度优先搜索的步骤，从顶点A出发，依次访问它的邻居节点，并将它们加入队列中。每次从队列中取出一个节点，再访问它的邻居节点，并将它们加入队列中，直到队列为空或者访问完所有节点为止。访问的顺序如下：
```
# 用 [] 表示队列，用 () 表示当前访问的节点
# 初始状态：[A]
# 访问A，并将A的邻居B和C加入队列：(A) [B, C]
# 访问B，并将B的邻居D加入队列：(B) [C, D]
# 访问C，并将C的邻居E加入队列：(C) [D, E]
# 访问D，并将D的邻居F和G加入队列：(D) [E, F, G]
# 访问E，并将E的邻居G加入队列：(E) [F, G, G]
# 访问F，并将F的邻居G加入队列：(F) [G, G, G]
# 访问G，并将G的邻居H加入队列：(G) [G, G, H]
# 访问G，发现已经访问过，跳过：(G) [G, H]
# 访问G，发现已经访问过，跳过：(G) [H]
# 访问H，发现没有邻居，结束：(H) []
```

根据上述过程，我们可以得到广度优先搜索序列为：
```
A,B,C,D,E,F,G,H

```

</details>


## 假设有5个进程，它们的到达时间和服务时间如下，单位为ms:
P1:(0,8),P2:(1,4),P3:(2,9),P4:(3,5),P5:(4,2)
使用先来先服务调度算法，求这5个进程的平均周转时间（保留两位小数) ()

A. 11.80

B. 16.00

C. 17.00

D. 12.20

<details close>
<summary>答案解析</summary>

先来先服务调度算法(FCFS)是一种最简单的调度算法，它总是选择最先到达的进程运行，直到该进程完成或阻塞。它既可以用于作业调度，也可以用于进程调度。

根据先来先服务调度算法的定义，我们可以按照以下步骤求解题目中的平均周转时间：

- 首先，我们可以将题目中给出的进程按照到达时间排序，如下表所示：

| 进程 | 到达时间 | 服务时间 |
| --- | --- | --- |
| P1 | 0 | 8 |
| P2 | 1 | 4 |
| P3 | 2 | 9 |
| P4 | 3 | 5 |
| P5 | 4 | 2 |

- 然后，我们可以计算每个进程的开始时间、完成时间、周转时间和带权周转时间，如下表所示：

| 进程 | 到达时间 | 服务时间 | 开始时间 | 完成时间 | 周转时间 | 带权周转时间 |
| --- | --- | --- | --- | --- | --- | --- |
| P1 | 0 | 8 | 0 | 8 | 8 - 0 = 8 | 8 / 8 = 1.00 |
| P2 | 1 | 4 | 8 | 12 | 12 - 1 = 11 | 11 / 4 = 2.75 |
| P3 | 2 | 9 | 12 | 21 | 21 - 2 = 19 | 19 / 9 = 2.11 |
| P4 | 3 | 5 | 21 | 26 | 26 - 3 = 23 | 23 / 5 = 4.60 |
| P5 | 4 | 2 | 26 | 28 | 28 - 4 =24|24 /2=12.00|

- 最后，我们可以求出平均周转时间和平均带权周转时间，如下所示：

$$
\text{平均周转时间}=\frac{\text{周转时间之和}}{\text{进程个数}}=\frac{8+11+19+23+24}{5}=17.00
$$

$$
\text{平均带权周转时间}=\frac{\text{带权周转时间之和}}{\text{进程个数}}=\frac{1.00+2.75+2.11+4.60+12.00}{5}=4.49
$$

因此，题目中的平均周转时间是**17.00**毫秒，平均带权周转时间是**4.49**。
那么应该选择 C
</details>


## 已知二叉树有a，b，c，d，e，f，g 这7个节点，二叉树的先序遍历序列的前五个序列是cdfba,二叉树去掉叶子节点的中序遍历序列是 cfdba,则它的后序遍历中第二个度为一的节点是()

A. a
B. b
C. f
D. c

<details close>
<summary>答案解析</summary>

TODO

</details>


## 求关键字13,19,11,9,8,7,21,10 依次插入到初始为空的小根堆H中，得到的H中根节点的值是()

A. 7

B. 9

C. 21

D. 11


<details close>
<summary>答案解析</summary>
先来介绍下小根堆：每个节点的值都小于或等于其子节点的值。也就是说，根节点是堆中的最小值

就是直接选择 A选项
</details>


## 已知一组关键字为{13,26,47,52,65,78,91,101,117,130}，采用线性探测法处理冲突，散列表是一个下标从0开始的长度为18的一维数组，散列函数为H(Key) = key MOD 18,则关键字65的结点地址是()

A. 5
B. 8
C. 15
D. 12

<details close>
<summary>答案解析</summary>

线性探测法是一种处理散列冲突的方法，它的基本思想是，当发生冲突时，从冲突位置开始，顺序查找表中下一个为空的存储地址，将待插入的记录存入。

散列函数是一种将关键字转换为散列地址的函数，常用的散列函数有除留余数法、直接定址法、平方取中法等。

题目中给出了一组关键字和一个散列函数H(Key) = key MOD 18，也就是说，将关键字除以18取余数作为散列地址。我们可以按照这个散列函数和线性探测法来计算每个关键字的结点地址：
| 关键字 | 散列地址 | 结点地址 |
| ------ | -------- | -------- |
| 13     | 13 MOD 18 = 13 | 13 |
| 26     | 26 MOD 18 = 8  | 8  |
| 47     | 47 MOD 18 = 11 | 11 |
| 52     | 52 MOD 18 = 16 | 16 |
| 65     | 65 MOD 18 = 11 | 12 |
| 78     | 78 MOD 18 = 6  | 6  |
| 91     | 91 MOD 18 = 1  | 1  |
| 101    | 101 MOD 18 = 11| 13 |
| 117    | 117 MOD 18 = 9 | 9  |
| 130    | 130 MOD 18 = 14| 14 |

可以看到因为65的散列地址是11，但是11已经被47占用了，顺延下去就是12了

所以这里选择 D
</details>


## 在平面直角坐标系中，起点为(1,1),每一步只能沿着网格线向x轴或者y轴正方向移动1个单位长度。例如，(1,2)走一步只能沿着x轴正方向走到(2,3)或者沿着y轴正方向走到(1,3)。若重点为(5,6)且中途不经过(2,4)的路径有()条？

A. 81
B. 86
C. 322
D. 128



<details close>
<summary>答案解析</summary>
这是一个有关组合数学的题目，组合数学是研究有限或可数无限离散结构的数学分支，它涉及到排列、组合、二项式系数、递归、生成函数等概念。

题目中给出了一个平面直角坐标系，要求从(1,1)走到(5,6)，每一步只能向右或者向上走一格，且不能经过(2,4)。我们可以用一种简单的方法来解决这个问题，就是用字母R和U来表示向右和向上走一格，那么任意一条从(1,1)走到(5,6)的路径都可以用一个由4个R和5个U组成的字符串来表示，例如RRUUURURU。反之，任意一个由4个R和5个U组成的字符串都可以表示一条从(1,1)走到(5,6)的路径。因此，问题就转化为了求有多少个不同的由4个R和5个U组成的字符串。

这个问题可以用组合公式来解决，组合公式是指从n个不同元素中取出m个元素的所有可能的组合数，记为C(n,m)，它等于n!/(m!(n-m)!),其中n!表示n的阶乘。在这个问题中，n=9，m=4或者m=5，因为R和U的位置可以互换。所以，C(9,4)=C(9,5)=126。

但是，这个结果还没有考虑到不能经过(2,4)这个条件。我们可以用排除法来处理这个条件，也就是说，先求出所有经过(2,4)的路径的数量，然后从总数中减去它们。要经过(2,4)，就必须先从(1,1)走到(2,4)，再从(2,4)走到(5,6)，这两段路径都可以用上面的方法来计算。从(1,1)走到(2,4)，需要1个R和3个U，共有C(4,1)=4种可能；从(2,4)走到(5,6)，需要3个R和2个U，共有C(5,3)=10种可能。所以，经过(2,4)的路径总共有4*10=40种。

因此，不经过(2,4)的路径总共有126-40=86种。

所以，正确答案是86条。选择B

</details>

## A和B建立了TCP连接，A端向B端发送数据，MSS=1KB，RTT=15ms。如果线路采用慢开始控制策略，接收窗口为20KB，则A端向B端发送出第一个完全窗口需要多少时间?

<details close>
<summary>答案解析</summary>
根据题目提供的信息，我们可以计算A端向B端发送第一个完整窗口所需的时间。在慢启动阶段，发送方的拥塞窗口大小每经过一个往返时间（RTT）加倍，直到达到接收窗口的大小。下面是计算过程：

MSS（最大报文段长度）为1KB，即每个TCP报文段的大小为1KB。
接收窗口大小为20KB，即B端能够接收的数据量为20KB。
在慢启动阶段，初始拥塞窗口大小为1个MSS，即1KB。
在每个往返时间（RTT）内，拥塞窗口大小翻倍，直到达到接收窗口的大小。
首先，计算拥塞窗口的翻倍次数。每次翻倍，拥塞窗口的大小加倍，直到达到20KB。假设翻倍次数为n，那么有以下关系：
1KB * 2^n = 20KB

解以上方程，我们得到：
2^n = 20KB / 1KB

要满足 2^n >= 20

取对数，得到：
n = log2(20) ≈ 4.32

由于窗口大小必须是整数，我们向上取整，所以n = 5。

接着，计算发送第一个完整窗口所需的时间。在慢启动阶段，拥塞窗口的大小每个RTT翻倍一次。因此，发送第一个完整窗口所需的时间为：
RTT * n = 15ms * 5 = 75ms

因此，A端向B端发送第一个完整窗口需要75毫秒的时间。
所以选择 D选项

</details>


## 已知一个有序表(10,16,21,27,36,45,51,62,73,87,96),当二分查找值为51的元素时，查找成功的比较次数为()
(提示：初始时low取值为数组的第一个元素的索引，high取值为数组的最后一个元素的索引；mid = (low+high)/2 向下取整)

A. 1
B. 2
C. 4
D. 3


<details close>
<summary>答案解析</summary>
题目中给出了一个有序表(10,16,21,27,36,45,51,62,73,87,96)，要求用二分查找值为51的元素，并给出了一些提示。我们可以按照以下步骤来进行二分查找，并记录每次的比较次数：

第一步：初始时，low=0，high=10，mid=(0+10)/2=5，即中间元素为45。比较51和45，51大于45，所以在右子区间继续查找。比较次数为1。
第二步：更新low=mid+1=6，high不变，mid=(6+10)/2=8，即中间元素为73。比较51和73，51小于73，所以在左子区间继续查找。比较次数为2。
第三步：更新high=mid-1=7，low不变，mid=(6+7)/2=6，即中间元素为51。比较51和51，相等，所以查找成功。比较次数为3。
因此，在二分查找值为51的元素时，查找成功的比较次数为3。

所以，正确答案是3。选择D

</details>

## 考虑对数方程 $3\log{k}{\sqrt{x}\log{k}{}x}\;=\;56$ 且 $\log{\log{k}{x}}{x} \;=\; 54$ 。如果这组方程有且仅有一个大于1的实根，那么k的值和唯一的实根为()

A. $216,6^{108}$
B. $128,6^{128}$
C. $156,6^{128}$
D. $144,6^{108}$

<details close>
<summary>答案解析</summary>
AI都不会做，略

</details>


## 若以{4,6,8,10,12,14}作为叶子结点的权值构造一颗哈夫曼树，则其带权路径长度是()

A. 100
B. 112
C. 136
D. 124

<details close>
<summary>答案解析</summary>

Huffman Tree是一种特殊的二叉树，它可以用来对数据进行压缩和编码。
构造哈夫曼树的步骤如下：

1. 将叶子结点按照权值从小到大进行排序：{4, 6, 8, 10, 12, 14}。

2. 从排序后的叶子结点中选取权值最小的两个结点，将它们合并为一个新的内部结点，该内部结点的权值为两个子结点的权值之和。将这个新的内部结点放入叶子结点的集合中。
   
3. 重复步骤2，直到只剩下一个结点，即根结点


最后得出的huffman tree 样子如下
```
           54
          /  \
        32    22
       / \    /  \
     18   14 10  12
    / \
   10  8
   / \
  4   6
```

huffman tree的带权路径长度（WPL）等于树中各叶子结点的权值乘以它们到根结点的路径长度之和
那么计算每个结点的权值分别是

| node | weight|
| -- | -- |
| 4*4 | 16 |
| 6*4 | 24|
|8*3  | 24 |
|14*2 | 24|
|2*10 | 20|
|12*2 | 24|

总共加起来就是 136.选择C

</details>


## 对数组a=[3,6,2,9,4,7]采用快速排序的方法，以第一个元素为基准，从小到大排序，则第一次得到的划分结果是()

A. [2,3,6,9,4,7]
B. [3,2,6,9,4,7]
C. [3,2,4,6,9,7]
D. [2,3,4,6,9,7]


<details close>
<summary>答案解析</summary>
快速排序是一种常用的排序算法，它的基本思想是通过一趟排序将待排序的数组分成两个子数组，其中一个子数组的所有元素都小于另一个子数组的所有元素，然后对这两个子数组继续进行快速排序，直到整个数组有序。

题目中给出了一个数组a=[3,6,2,9,4,7]，要求采用快速排序的方法，以第一个元素为基准，从小到大排序。我们可以按照以下步骤来进行：

第一步：选择第一个元素3作为基准，设置两个指针i和j，分别指向数组的首尾，即i=0，j=5。
第二步：j从右向左扫描，寻找第一个小于基准的元素。当j=2时，找到了2，它小于基准3.
i 从左从右扫描，寻找第一个大于基准的元素。当i=1时，找到了6，它大于基准3
所以将2和6交换位置，即a[0]=2，a2=3。此时i=1，j=2。
数组为[3,2,6,9,4,7]

第三步：因为i++会大于等于j导致循环步骤退出，退出后交换基准元素3和i所在的值6
就变成了 [2,3,6,9,4,7]

所以选择 A
> PS: 最好的方式是将基准元素移到数组的末尾，但是选项里面并没有对应的答案
</details>

## 串S="backslide"的子串个数为()

A. 34
B. 38
C. 49
D. 46

<details close>
<summary>答案解析</summary>
根据子串计算公式 $\frac{n(n+1)}{2}+1$公式 （+1是指空串也是子串）
我们直接计算出 $\frac{9*10}{2}+1 = 46$

选择D
</details>

## 考虑函数 $f(x) = ax^{2} - 2021x + 2022$且 $a > 0 $,如果 $f(x)$在区间 $[t-1,t+1]$ 上的最大值为 $Q(t)$,且最小值为 $q(t)$.定义函数 $h(t) = Q(t) - q(t)$， $h(t)$的最小值为1，那么a的可能的值为 ()

A. 0
B. 1
C. 3
D. 2

<details close>
<summary>答案解析</summary>
把AI整懵逼了



</details>


## 下列关于MySQL内建的存储引擎Mmeory引擎说法错误是()

A. Memory表可以用于查找或映射表
B. Memory表不支持hash索引
C. 通常在查询中，存储中间结果的临时表就是Memory表
D. Memory表使用表级锁

<details close>
<summary>答案解析</summary>
Memory 表最开始是只支持Hash索引（等值查询），我看的[最新版本8.0](https://dev.mysql.com/doc/refman/8.0/en/memory-storage-engine.html)对于Memory 表是也支持了B-tree 索引（范围查询）

MySQL有三种级别的锁：row-level(行锁),page-level (页面锁),table-level (表锁)

其中row-level和page-level只有Innodb 支持
Memory和MyISAM 只支持table-level,不过Memory 表在内存上，即使是表锁也能达到很高的性能

</details>