# 基础题目

- [基础题目](#基础题目)
  - [1.一个子网掩码是`255.255.248.0`，这个子网能拥有的最大主机数是().](#1一个子网掩码是2552552480这个子网能拥有的最大主机数是)
  - [Linux 系统根目录下哪个目录包含系统库文件()](#linux-系统根目录下哪个目录包含系统库文件)
  - [某高校实验室的计算机系统采用二级页表，其中虚地址被分为 8 位一级页表，10 位二级页表和偏移。若该计算机系统采用 32 位地址，则页面大小是()](#某高校实验室的计算机系统采用二级页表其中虚地址被分为-8-位一级页表10-位二级页表和偏移若该计算机系统采用-32-位地址则页面大小是)
  - [下面函数需要将两个升序数组合并为一个升序数组，序号处空缺代码应补充为()](#下面函数需要将两个升序数组合并为一个升序数组序号处空缺代码应补充为)
  - [下列不属于衡量 Mysql 查询开销的指标是？](#下列不属于衡量-mysql-查询开销的指标是)
  - [客户机 A 向服务器 B 发起 TCP 连接请求，已知第三次握手时的确认报文段中 ack = 2048,seq = 1024,问客户机 A 向服务器 B 发送连接请求报文段为()](#客户机-a-向服务器-b-发起-tcp-连接请求已知第三次握手时的确认报文段中-ack--2048seq--1024问客户机-a-向服务器-b-发送连接请求报文段为)
  - [在数据库的规范化函数依赖中存在 Armstrong 公理，下列不属于 Armstrong 性质的是?](#在数据库的规范化函数依赖中存在-armstrong-公理下列不属于-armstrong-性质的是)
  - [n 为变量，当执行 dp(n,0)时，下列程序的复杂度为()](#n-为变量当执行-dpn0时下列程序的复杂度为)
  - [下面表格为一条被截断的单链表的数据结构：](#下面表格为一条被截断的单链表的数据结构)
  - [find -size n 命令表示查找 n 值大小的文件，默认单位是块(1 块=512 字节)](#find--size-n-命令表示查找-n-值大小的文件默认单位是块1-块512-字节)
  - [按照以下序列顺序插入，建立二叉排序树，请问值为 7 的结点深度是()](#按照以下序列顺序插入建立二叉排序树请问值为-7-的结点深度是)
  - [下列选项中，不在核心态执行的是()](#下列选项中不在核心态执行的是)
  - [关系数据库中的”范式“是指什么 ()](#关系数据库中的范式是指什么-)
  - [](#)

## 1.一个子网掩码是`255.255.248.0`，这个子网能拥有的最大主机数是().

A. 255
B. 2048
C. 4094
D. 2046

<details close>
<summary>答案解析</summary>

这是一道有关于子网划分的题目。子网划分是一种将一个 IP 地址空间分成若干个更小的子网的方法，以提高 IP 地址的利用率和网络的管理效率。

要解答这个题目，我们需要知道子网掩码和主机数之间的关系。子网掩码是一个 32 位的二进制数，用来区分**网络号**和**主机号**。**网络号**表示一个子网的标识，主机号表示一个子网内的主机的标识。子网掩码中，1 代表网络位，0 代表主机位 2。

子网能拥有的最大主机数是由主机位决定的。主机位越多，可用的主机数越多。**可用的主机数等于 2 的主机位数次方减去 2**。
这里减去 2 是因为每个子网的主机号全为 0 或全为 1 时是保留地址，不能分配给主机。
**主机号全为 0 的地址表示本网络，也叫子网号**。
**主机号全为 1 的地址表示广播地址**，用来向本网络内的所有主机发送消息。这两个地址都不能作为普通主机的 IP 地址，所以在最后主机号最后要减去 2。

当然这个也不一定的，比如说 cloudflare CDN 的 IP 地址就没有这种顾虑，全 1 或者全 0 都是可以作主机号来使用的

现在我们来看题目中给出的子网掩码 255.255.248.0，它对应的二进制数是 11111111.11111111.11111000.00000000。我们可以看到，它有 11 个主机位（后面的 11 个 0）。所以，这个子网能拥有的最大主机数是$2^{11}-2=2046$。
因此，正确答案是**D 选项**。

</details>

## Linux 系统根目录下哪个目录包含系统库文件()

A. /bin
B. /etc
C. /usr
D. /lib

<details>
<summary>答案解析</summary>

要解答这个题目，我们需要知道系统库文件的含义和位置。系统库文件是一些包含了预编译的代码和数据的文件，它们可以被多个程序共享，以提高程序的性能和节省内存空间。系统库文件通常有两种类型：**静态库**和**动态库**。静态库在程序编译时被链接到程序中，动态库在程序运行时被加载到内存中。

在 Linux 系统中，系统库文件一般存放在`/lib`或`/usr/lib`目录下。`/lib`目录包含了一些基本的、必须的、与硬件相关的系统库文件，例如 C 语言运行时库 libc.so。`/usr/lib`目录包含了一些非必须的、与硬件无关的系统库文件，例如 GTK+图形库 libgtk.so。

因此，正确答案是 D 选项。

</details>

## 某高校实验室的计算机系统采用二级页表，其中虚地址被分为 8 位一级页表，10 位二级页表和偏移。若该计算机系统采用 32 位地址，则页面大小是()

A. 2^{8}
B. 2^{10}
C. 2^{18}
D. 2^{14}

<details>
<summary>答案解析</summary>

要解答这个题目，我们需要知道二级页表的结构和页面大小的计算方法。二级页表是一种将一个大的页表分成若干个小的页表的方法，以减少页表占用的内存空间和提高页表查找的效率。

二级页表的结构是将虚地址分为三部分：一级页表、二级页表和偏移。一级页表用来指定二级页表所在的物理块号，二级页表用来指定页面所在的物理块号，偏移用来指定页面内的具体位置。

**页面大小是由偏移决定的**。偏移越多，页面越大。页面大小等于 2 的偏移位数次方。

现在我们来看题目中给出的二级页表，它将 32 位虚地址分为 8 位一级页表，10 位二级页表和偏移。我们可以看到，它有 14 位偏移（后面的 14 位）。所以，页面大小是$2^{14}=16384$字节。因此，正确答案是 D 选项。

</details>

## 下面函数需要将两个升序数组合并为一个升序数组，序号处空缺代码应补充为()

```c++
vector<int> merge(vector<int> a,vector<int> b){
    vector<int> res;
    int i, j, n, m;
    i = j = 0;
    n =  a.size();
    m = b.size();
    while({1}){
        if(a[i] < b[j]){
            res.push_back(a[i]);
            i++;
        } else {
            res.push_back(b[j]);
        }
    }

    while({2}){
        res.push_back(a[i]);
    }
    while({3}){
        res.push_back(b[j]);
    }
    return res;
}
```

A. {1}i<n&&j<m{2}i<n{3}j<m
B. {1}i<=n&&j<=m{2}j<m{3}i<n
C. {1}i<=n&&j<=m{2}i<n{3}j<m
D. {1}i<n&&j<m{2}j<m{3}i<n

<details>
<summary>答案解析</summary>
非常经典的合并数组操作，合并两个升序数组是一种常见的排序算法，它属于分治法的一种应用。
合并两个升序数组的思路是，使用两个指针分别指向两个数组的第一个元素，比较它们的大小，将较小的元素放入结果数组中，并移动相应的指针，直到其中一个数组遍历完毕，然后将另一个数组剩余的元素全部放入结果数组中。

要解答这个题目，我们需要知道空缺代码处应该填写什么条件。{1}处的条件是用来判断两个数组是否都还有未遍历的元素，如果是，则继续比较和合并。{2}处和{3}处的条件是用来判断哪个数组还有剩余的元素，如果有，则将它们全部放入结果数组中。

根据上述分析，正确答案是 A 选项。{1}处应该填写 i<n&&j<m，表示两个指针都没有超出各自数组的范围。{2}处应该填写 i<n，表示第一个数组还有剩余的元素。{3}处应该填写 j<m，表示第二个数组还有剩余的元素。

</details>

## 下列不属于衡量 Mysql 查询开销的指标是？

A. 响应时间
B. 扫描行数
C. 返回行数
D. 数据表的数量

<details>
<summary>答案解析</summary>
这是一道有关于衡量MySQL查询开销的指标的题目。查询开销是指执行一个查询所需要消耗的资源和时间，它反映了查询的效率和性能。对于MySQL，最简单的衡量查询开销的三个指标如下：

- 响应时间：是指从客户端发送查询到服务器返回结果所花费的总时间，它包括服务时间和排队时间。服务时间是指数据库处理这个查询真正花了多长时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间，比如等待 I/O 操作或者锁等。

- 扫描行数：是指 MySQL 在执行这个查询时需要访问的数据表中的行数，它反映了查询的选择性和精确性。扫描行数越少，说明查询越能准确地定位到需要的数据，而不是浪费时间和资源在无关的数据上。

- 返回行数：是指 MySQL 在执行这个查询后返回给客户端的结果集中的行数，它反映了查询的结果量和复杂度。返回行数越少，说明查询越能满足客户端的需求，而不是返回过多的无用或重复的数据。

根据上述分析，我们可以看出，数据表的数量并不是一个衡量 MySQL 查询开销的指标，因为它与查询本身的效率和性能没有直接关系。**数据表的数量只是反映了数据库的结构和设计**，并不影响单个查询所消耗的资源和时间。因此，正确答案是 D 选项。

</details>

## 客户机 A 向服务器 B 发起 TCP 连接请求，已知第三次握手时的确认报文段中 ack = 2048,seq = 1024,问客户机 A 向服务器 B 发送连接请求报文段为()

A. SYN = 1,seq = 1024
B. SYN = 1,ACK = 1,seq = 2047, ack = 1024
C. SYN = 1,ACK = 1,seq = 2047, ack = 1023
D. SYN = 1,seq = 1023

<details>
<summary>答案解析</summary>

这是一道有关于 TCP 连接请求报文段的题目。TCP 连接请求报文段是用来建立 TCP 连接的报文段，它包含了同步位 SYN 和序号 seq 两个字段。SYN 表示这是一个连接请求或连接接受报文，seq 表示本报文段发送的数据的第一个字节的序号。

要解答这个题目，我们需要知道 TCP 三次握手的过程和原理。TCP 三次握手是一种用来建立可靠的双向通信的方法，它包括以下三个步骤 3：

1. 第一次握手：客户机 A 向服务器 B 发起连接请求报文段，设置`SYN=1`，选择一个初始的序号`seq=x`。

2. 第二次握手：服务器 B 收到连接请求报文段后，如果同意连接，则回复一个确认报文段，设置`SYN=1，ACK=1`，确认号`ack=x+1`，选择一个初始的序号`seq=y`。
3. 第三次握手：客户机 A 收到确认报文段后，再次回复一个确认报文段，设置 ACK=1，确认号`ack=y+1`，序号`seq=x+1`。

现在我们来看题目中给出的第三次握手时的确认报文段中`ack = 2048,seq = 1024`。这意味着客户机 A 收到了服务器 B 的确认报文段，其中`seq=y=2047，ack=x+1=1024`。根据第三次握手的原理，我们可以推断出客户机 A 向服务器 B 发送连接请求报文段时，设置了`SYN=1，seq=x=1023`。因此，正确答案是 D 选项。

</details>

## 在数据库的规范化函数依赖中存在 Armstrong 公理，下列不属于 Armstrong 性质的是?

A. 自反性
B. 增广性
C. 不可传递性
D. 分解性

<details>
<summary>答案解析</summary>

这是一道有关于数据库的规范化函数依赖和 Armstrong 公理的题目。函数依赖是一种反映属性之间约束关系或依赖关系的概念。Armstrong 公理是一组用来推导函数依赖的基本规则，它包括自反律、增广律和传递律。

要解答这个题目，我们需要知道 Armstrong 性质的定义和含义。

Armstrong 性质是指满足以下三个条件的性质：

1. 如果一个函数依赖集合 F 满足某个性质，那么 F 的闭包 F+也满足这个性质。
2. 如果一个函数依赖集合 F 满足某个性质，那么 F 中的任何函数依赖也满足这个性质。
3. 如果一个函数依赖集合 F 满足某个性质，那么由 F 逻辑蕴含的任何函数依赖也满足这个性质。

根据上述分析，我们可以看出，自反律、增广律和分解律都是 Armstrong 性质，因为它们都符合上述三个条件。但是不可传递性不是 Armstrong 性质，因为它违反了第三个条件。不可传递性是指如果 X→Y 且 Y→Z，那么 X→Z 不一定成立。但是根据传递律，我们知道 X→Y 且 Y→Z 可以逻辑蕴含 X→Z2。因此，不可传递性不是由 F 逻辑蕴含的性质。因此，正确答案是 C 选项。

更多资料请查阅 https://en.wikipedia.org/wiki/Armstrong%27s_axioms

</details>

## n 为变量，当执行 dp(n,0)时，下列程序的复杂度为()

```c++
int dp(int n,int num){
    if (!n) {
        return num;
    }

    int ans = 0;
    for(int i = 0;i <= 1; i++){
        ans += dp(n-1,num+i)
    }
    return ans;
}
```

A. $O(n)$
B. $O(n!)$
C. $O(n^{2})$
D. $O(2^{n})$

<details>
<summary>答案解析</summary>

要解答这个题目，我们需要知道如何计算时间复杂度。时间复杂度的计算方法是使用大 O 表示法，它表示了程序运行时间随着输入规模 n 的增长情况。一般来说，我们只关注程序中最耗时的部分，并忽略掉常数因子和低阶项。

现在我们来看题目中给出的程序，它是一个递归函数，用来计算一个数列的和。我们可以用以下方法来分析它的时间复杂度：

1. 首先，我们看到函数中有一个**for 循环**，它执**行了两次**，每次调用了 dp(n-1,num+i)。这意味着每次递归都会产生两个子问题，而每个子问题的规模**都比原问题小 1**。

2. 其次，我们看到函数中有一个 if 语句，它判断 n 是否为 0。如果 n 为 0，那么函数直接返回 num，这是**递归的终止条件**。如果 n 不为 0，那么函数继续递归。

3. 最后，我们看到函数中没有其他耗时的操作，所以我们可以忽略掉常数因子和低阶项。
   综上所述，我们可以得到以下递推关系式：

$$
T(n) = 2T(n-1) + O(1)
$$

这个递推关系式表示了函数执行时间随着 n 的变化情况。我们可以用主定理来求解它，得到：

$$
T(n) = O(2^n)
$$

因此，正确答案是 D 选项。

</details>

## 下面表格为一条被截断的单链表的数据结构：

| 存储地址 | 数据域 | 指针域 |
| -------- | ------ | ------ |
| 1        | LI     | 92     |
| 14       | QIAN   | 27     |
| 27       | SUM    | 1      |
| 40       | CHEN   | 105    |
| 53       | PIN    | 79     |
| 66       | ZHOU   | 14     |
| 79       | XIN    | 40     |
| 92       | YAN    | 53     |

链表的此部分数据排列顺序是()

A. ZHOU->QIAN->SUM->LI->YAN->PIN->XIN->CHEN
B. CHEN->XIN->PIN->YAN->LI-SUM->QIAN->ZHOU
C. YAN->XIN->ZHOU->PIN->CHEN->SUM->QIAN->LI
D. LI->QIAN->SUM->CHEN->PIN->ZHOU->XIN->YAN

<details>
<summary>答案解析</summary>
这是一道有关于单链表的数据结构的题目。单链表是一种链式存储的数据结构，每个结点包含一个数据域和一个指针域，指针域存放下一个结点的地址。
```c
struct node {
	string data;        // 数据域
	struct node *next;  // 指针域
};
```

要解答这个题目，我们需要根据指针域的值来确定链表的顺序。我们可以从任意一个结点开始，然后沿着指针域的方向遍历链表，直到遇到空地址或者循环结束。

B 选项中 CHEN 的指针域指向了不存在的 105
C 选项中 YAN 的指针域指向 PIN 才对
D 选项中 LI 的指针域指向 YAN 才对

故此只有选项 A 是正确的.

</details>

## find -size n 命令表示查找 n 值大小的文件，默认单位是块(1 块=512 字节)

如果在 home 目录下查找大于 10M 并且小于 20M 的文件，下面命令正确的是()

A. find /home -size +10 -a -20
B. find /home -size +10240 -a -20480
C. find /home -size +20480 -a -size -40960
D. find /home -size +20480 -a -40960

<details>
<summary>答案解析</summary>
这是一道有关于find命令按照文件大小搜索的题目。find命令是Linux中强大的搜索命令，不仅可以按照文件名搜索文件，还可以按照权限、大小、时间、inode号等来搜索文件1。

要解答这个题目，我们需要知道 find 命令的-size 选项的用法和单位。-size 选项是用来按照指定大小搜索文件的，它支持使用+或-表示大于或小于指定大小，单位可以是 c（字节）、w（字数）、b（块数）、k（KB）、M（MB）或 G（GB）2。

现在我们来看题目中给出的四个选项，它们都使用了 b（块数）作为单位。我们知道一块等于 512 字节，所以 10M 等于 10240 块，20M 等于 20480 块。因此，我们可以排除 A 和 B 选项，因为它们没有正确地转换单位。

接下来我们来看 C 和 D 选项，它们都使用了+和-表示大于或小于指定大小。我们知道+表示大于，-表示小于。因此，我们可以排除 D 选项，因为它使用了-a 表示逻辑与，但是没有使用-size 指定第二个大小条件。

最后我们来看 C 选项，它使用了+20480 表示大于 10M，-size -40960 表示小于 20M。这符合题目中要求查找大于 10M 并且小于 20M 的文件的条件。因此，正确答案是 C 选项。

</details>

## 按照以下序列顺序插入，建立二叉排序树，请问值为 7 的结点深度是()

```
1 3 -2 10 7 8 19
```

A. 2
B. 3
C. 5
D. 4

<details>
<summary>答案解析</summary>
要解答这个题目，我们需要按照给定的序列顺序插入结点，建立二叉排序树，然后计算值为7的结点深度。我们可以用以下方法来建立二叉排序树3：

1. 首先，将第一个数 1 作为根结点插入；
2. 其次，将第二个数 3 与根结点比较，发现 3 大于 1，因此将 3 作为 1 的右孩子插入；
   接下来，将第三个数-2 与根结点比较，发现-2 小于 1，因此将-2 作为 1 的左孩子插入；
   依次类推，将剩余的数按照大小关系插入到合适的位置。
3. 最后，我们得到如下图所示的二叉排序树：

```
      1
     / \
   -2   3
         \
          10
         /  \
        7    19
       / \
      8   9

```

从图中可以看出，值为 7 的结点是 10 的左孩子，10 是 3 的右孩子，3 是 1 的右孩子。因此，值为 7 的结点深度为 3。
选项 B 为正确答案

</details>

## 下列选项中，不在核心态执行的是()

A. 命令解释程序
B. 缺页处理程序
C. 时钟中断处理程序
D. 进程调度程序

<details>
<summary>答案解析</summary>

一般来说，操作系统中的内核程序都在核心态执行，而用户程序都在用户态执行。

要解答这个题目，我们需要知道其他三个选项都是什么，并且为什么它们都在核心态执行。其他三个选项都是操作系统中的内核程序：

- 缺页处理程序：是一种用来处理虚拟内存中发生的缺页异常的程序，它需要在核心态执行，因为它需要访问物理内存和磁盘。

- 时钟中断处理程序：是一种用来处理时钟信号产生的中断请求的程序，它需要在核心态执行，因为它需要访问时钟设备和调整进程状态。

- 进程调度程序：是一种用来管理进程运行顺序和分配处理器资源的程序，它需要在核心态执行，因为它需要访问进程控制块和切换进程上下文。

命令解释器是在用户态上解析命令后，才根据命令的需要与否才需要进入到内核态中操作
所以不在核心态执行的选项是 A 选项。因此，正确答案是 A 选项。

</details>

## 关系数据库中的”范式“是指什么 ()

A. 数据存储的物理结构
B. 数据库的安全性机制
C. 数据库设计的规范化过程
D. 数据表中的索引

<details>
<summary>答案解析</summary>

这是一道有关于关系数据库中的范式的题目。范式是指关系数据库中数据组织的一种标准或规范，它用来减少数据冗余和提高数据完整性。范式有多个级别，从第一范式到第五范式，每个级别都有一些满足条件。

- **第一范式（1NF）**要求每个表格单元只包含一个值，每个列名都是唯一的，每行数据都有一个主键 1。第一范式有助于消除重复数据和简化查询。

- **第二范式（2NF）**要求每个非主键属性都完全依赖于主键 1。这意味着每个列都直接与主键相关，而不是与其他列相关。

- **第三范式（3NF）**要求所有非主键属性都互相独立 1。这意味着每个列都直接与主键相关，而不是与同一张表中的其他列相关。

- **Boyce-Codd 范式**（BCNF）是 3NF 的一个更严格的形式，要求表中的每个决定因素都是候选键 1。换句话说，BCNF 要求每个非主键属性只依赖于候选键。

- **第四范式（4NF）**要求表中不存在多值依赖 2。多值依赖是指一个属性的值决定了另一个属性的多个值。

- **第五范式（5NF）**要求表中不存在连接依赖 2。连接依赖是指一个表可以被分解为多个较小的表，而不损失任何信息。

要解答这个题目，我们需要知道其他三个选项都是什么，并且为什么它们都不是范式的含义。其他三个选项都是关系数据库中的其他概念：

- **数据存储的物理结构**：是指数据在磁盘上的存储方式，比如顺序存储、索引存储、散列存储等。
- **数据库的安全性机制**：是指保护数据库免受非法访问、修改或破坏的一系列措施，比如用户身份认证、访问控制、加密、审计等。

- **数据表中的索引**：是指用来加速数据检索的一种数据结构，比如 B 树、哈希表、位图等。
  综上所述，我们可以看出，不是范式含义的选项是 A、B 和 D 选项。因此，正确答案是 C 选项。

具体可以参阅下面资料:
[Normal Forms in DBMS – Database Normalization](https://www.geeksforgeeks.org/normal-forms-in-dbms/)

[What Is Database Normalization?](https://builtin.com/data-science/database-normalization)

</details>

##
